package appendix3;
import robocode.*;
import java.util.*;
//import java.awt.Color;

/*
	Doroideka:敵エネルギーの変化から、攻撃を察知し、横移動で避ける
	Battledoroidの機能を、AdvancedRobotクラスへ実装。
	テンプレートとして、Alisdair OwensのSnippetBotを参考にしている
	http://www.ecs.soton.ac.uk/%7Eawo101/robocode.html

	反重力移動として、Alisdair OwensのAntiGravityBotを参考にしている
	http://www-6.ibm.com/jp/developerworks/java/020930/j_j-antigrav.html

	Programing by Yutaka Katch
	2003-04-01	10	SnippedBotに中央移動を実装、回避と線形予測なし
				11	回避機能を実装
	2003-04-02	12	レーダーを再プログラミング、中央移動を削除
				13	SnippetBotのライブラリを削除
				14	線形予測を実装、LinerEnemyRadクラス
				15	被弾時の処理、勝利の処理を追加、バトル開始時にブロッキングメソッドで中央に移動
	2003-04-09	4th	反重力移動を実装
	Droideka_AntiGrav
	2003-09-17	00	ソースコードを整理
				01	回避機能を実装・設定値を調整
	
*/

public class Droideka_AntiGrav extends AdvancedRobot
{
	/**
	 * run: Droideka's default behavior
	 */
	
	final double PI = Math.PI;			//ラジアン用に円周率を定数化

	LinerEnemyRad target = new LinerEnemyRad();	//敵の情報を管理するクラス
	Hashtable targets = new Hashtable();		//敵情報管理クラスを集中管理するクラス

	Direction movDir = new Direction();				//進行方向を管理する
	Direction sweepDir = new Direction();				//レーダーの方向を管理する
	Lib help = new Lib();						//共有ライブラリを登録する	

	double firePower;       					//攻撃力
	double sweepKaku = PI;						//レーダーの往復量の初期値

	public void run() {

		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		setAdjustRadarForRobotTurn(true);

		turnRadarRightRadians(2*PI);			//360度索敵
		while(true) {
			doAntiGravMove();			//移動量を設定
			doScanner();				//レーダーの移動量を設定
			doGun();					//砲塔を敵に向ける
			if (firePower != 0 ) {fire(firePower);}
			execute();					//非ブロッキングメソッドを実行
		}
	}


	/*
	 * 反重力移動による移動方向を計算
	 */
	void doAntiGravMove() {
   		double xforce = 0;
	    double yforce = 0;
	    double force;
	    double ang;
	    GravPoint p;
		Enemy en;
    	Enumeration e = targets.elements();

		//各敵ロボットに対応した重力ポイントの反発力を合計する
		while (e.hasMoreElements()) {
    	    en = (Enemy)e.nextElement();
			if (en.live) {
				final double ENEMYFORCE = -1000;
				//生存している敵に"-1000"の反発力を設定する
				p = new GravPoint(en.x,en.y, ENEMYFORCE);
				//反発力を求める
		        force = p.power/Math.pow(help.getRange(getX(),getY(),p.x,p.y),2);
		        //自ロボットからの方向
		        ang = help.normalAngle(PI/2 - Math.atan2(getY() - p.y, getX() - p.x)); 
		        //反発力の各成分を合計する
		        xforce += Math.sin(ang) * force;
		        yforce += Math.cos(ang) * force;
			}
	    }

	    //四方の壁からの反発力を、3乗で加味する
		final double WALLFORCE = 5000;
	    xforce += WALLFORCE/Math.pow(help.getRange(getX(), getY(), getBattleFieldWidth(), getY()), 3);
	    xforce -= WALLFORCE/Math.pow(help.getRange(getX(), getY(), 0, getY()), 3);
	    yforce += WALLFORCE/Math.pow(help.getRange(getX(), getY(), getX(), getBattleFieldHeight()), 3);
	    yforce -= WALLFORCE/Math.pow(help.getRange(getX(), getY(), getX(), 0), 3);
	    
	    //移動設定	
		double kaku = getHeadingRadians() + Math.atan2(yforce, xforce) - PI/2;
		//方向転換する代わりに、後退するよう角度を補正
		int dir;
		if (kaku > PI/2) {
	        kaku -= PI;
	        dir = -1;
	    }
	    else if (kaku < -PI/2) {
	        kaku += PI;
	        dir = -1;
	    }
	    else {
	        dir = 1;
	    }

	    //エネルギーが変化していたときだけ、移動する。
	    double changeInEnergy = target.previousEnergy - target.energy;
	    if (changeInEnergy != 0) {
	    	//距離に応じて、移動量を変える
	    	double moveDistance;
		if (target.distance > 400) {
			moveDistance = 100;
		} else {
			moveDistance = 300;
		}
	    setTurnRightRadians(kaku);
	    setAhead(moveDistance * dir);
	    }

	}
			
	void doScanner() {
		setTurnRadarLeftRadians(2*PI);
	}

	void doGun() {
		firePower = 0;	

		//砲塔を予測地点に向ける	
		if (target.setNextXY(getX(), getY()) == true) {
			double nextX = target.nextX - getX();
			double nextY = target.nextY - getY();
			double kaiten = PI/2 - Math.atan2(nextY, nextX);
			setTurnGunRightRadians(help.normalAngle(kaiten - getGunHeadingRadians()));
			
			//予測地点が、バトルフィールド内のときだけ攻撃		
			if (target.nextX > 0 
				&& target.nextY > 0 
				&& target.nextX < getBattleFieldWidth() 
				&& target.nextY < getBattleFieldHeight()) {
					firePower = 1;
			}
		}
	}
	
	/**
	 * onScannedRobot: What to do when you see another robot
	 */
	public void onScannedRobot(ScannedRobotEvent e) {
		//敵ロボットの方向を求める
		double absbearing_rad = (getHeadingRadians()+e.getBearingRadians())%(2*PI);

		LinerEnemyRad en;
		if (targets.containsKey(e.getName())) {
			en = (LinerEnemyRad)targets.get(e.getName());
		} else {
			en = new LinerEnemyRad();
			targets.put(e.getName(),en);
		}

		//敵ロボットの情報をセットする
		en.name = e.getName();
		en.x = getX()+Math.sin(absbearing_rad)*e.getDistance(); //敵ロボットの現在位置Xを求める
		en.y = getY()+Math.cos(absbearing_rad)*e.getDistance(); //敵ロボットの現在位置Yを求める
		en.bearing = e.getBearingRadians();
		en.head = e.getHeadingRadians();
		en.checkTime = getTime();				//情報を記録した時間
		en.speed = e.getVelocity();
		en.distance = e.getDistance();

		en.live = true;
		if ((en.distance < target.distance)||(target.live == false)) {
			target = en;
		}

		en.setEnergy(e.getEnergy());			//敵ロボットのエネルギーを記録
	}

	/*
	 * 被弾時の処理
	 */
	public void onHitByBullet(HitByBulletEvent e) {
		turnRadarRight(getHeading() + e.getBearing() - getRadarHeading());
	}

	//敵ロボットの破壊時の処理
	public void onRobotDeath(RobotDeathEvent e) {
		Enemy en = (Enemy)targets.get(e.getName());
		en.live = false;		
	}	

}
